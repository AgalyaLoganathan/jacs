/**
 * Decrypt a ciphertext file generated by jacs
 * using C/OpenSSL instead of Java/JCE to verify
 * the consistency of jacs using an alternative
 * implementation.
 *
 * Note: unlike the Java version of jacs, this tool
 * reads files into memory and can't handle
 * file sizes larger than 2GB.
 *
 * build with: gcc -O2 dec.c -o dec -lcrypto
 */

#include <stdio.h>
#include <string.h>
#include <unistd.h> /* for getpass */

#ifdef USE_MLOCK
#include <sys/mman.h> /* for memlockall */
#endif

#define DEBUG 0

#include <openssl/err.h>
#include <openssl/conf.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>

#define CIPHER_KEY_LEN  32
#define HMAC_KEY_LEN    32
#define IV_LEN          16
#define HMAC_LEN        32

static const unsigned char cipher_salt[] = {
	0xe9, 0x66, 0x97, 0xb7,
	0xa6, 0xdb, 0x7f, 0x4a,
	0x45, 0x57, 0x76, 0xa0,
	0x91, 0x86, 0x32, 0x6e
};

static const unsigned char hmac_salt[] = {
	0xd6, 0x83, 0x8f, 0x7a,
	0x80, 0x5c, 0x33, 0x8a,
	0x8d, 0xc6, 0x19, 0x2d,
	0x0b, 0x0b, 0x45, 0x3e
};

static void dump_hex(const unsigned char *data, size_t len)
{
	size_t i;
	for (i = 0; i < len; ++i) {
		fprintf(stderr, "%02x", data[i]);
	}
}

int main(int argc, char *argv[])
{
	unsigned char cipher_key[CIPHER_KEY_LEN];
	unsigned char hmac_key[HMAC_KEY_LEN];
	unsigned char md[HMAC_LEN];

	unsigned char *ciphertext;
	int ciphertext_len;

	unsigned char *plaintext;
	int plaintext_len;

	int strength;

	const EVP_CIPHER *cipher_type;
	EVP_CIPHER_CTX *ctx;
	FILE *fp;
	int len;
	int status;
	long file_size;

	if (argc < 5) {
		fprintf(stderr, "dec -- decrypt jacs-format file\n");
		fprintf(stderr, "usage: dec <alg> <password> <strength> <infile> [outfile]\n");
		fprintf(stderr, "algs:\n");
		fprintf(stderr, "  PBKDF2-SHA1-AES256-HMAC-SHA256\n");
		fprintf(stderr, "password : password or 'p' to prompt from stdin without echo\n");
		fprintf(stderr, "strength : key derivation complexity\n");
		fprintf(stderr, "infile   : input file\n");
		fprintf(stderr, "outfile  : output file, defaults to stdout\n");
		return 2;
	}

#ifdef USE_MLOCK
	/* For security, disable paging */
	if (mlockall(MCL_CURRENT|MCL_FUTURE)) {
		fprintf(stderr, "mlockall() failed\n");
		return 1;
	}
#endif

	/* Initialise OpenSSL */
	ERR_load_crypto_strings();
	OpenSSL_add_all_algorithms();
	OPENSSL_config(NULL);

	/* Get strength */
	strength = atoi(argv[3]);
	if (strength < 1 || strength > 31) {
		fprintf(stderr, "strength must be between 1 and 31\n");
		return 1;
	}

	/* Possibly read password from console */
	if (!strcmp(argv[2], "p"))
		argv[2] = getpass("Password:");

	/* Derive cipher key */
	status = PKCS5_PBKDF2_HMAC_SHA1(argv[2], strlen(argv[2]),
					cipher_salt, sizeof(cipher_salt),
				    1<<strength,
					sizeof(cipher_key), cipher_key);
	if (!status) {
		fprintf(stderr, "PKCS5_PBKDF2_HMAC_SHA1 (cipher) failed\n");
		return 1;
	}
#if DEBUG
	fprintf(stderr, "Cipher key: ");
	dump_hex(cipher_key, sizeof(cipher_key));
	fprintf(stderr, "\n");
#endif

	/* Derive HMAC key */
	status = PKCS5_PBKDF2_HMAC_SHA1(argv[2], strlen(argv[2]),
					hmac_salt, sizeof(hmac_salt),
					1<<strength,
					HMAC_KEY_LEN, hmac_key);
	if (!status) {
		fprintf(stderr, "PKCS5_PBKDF2_HMAC_SHA1 (hmac) failed\n");
		return 1;
	}
#if DEBUG
	fprintf(stderr, "HMAC key:   ");
	dump_hex(hmac_key, sizeof(hmac_key));
	fprintf(stderr, "\n");
#endif

	/* Load ciphertext file into memory */
	fp = fopen(argv[4], "r");
	if (!fp) {
		fprintf(stderr, "cannot open input ciphertext file %s\n", argv[4]);
		return 1;
	}
	if (fseek(fp, 0L, SEEK_END)) {
		fprintf(stderr, "fseek failed\n");
		return 1;
	}
	file_size = ftell(fp);
	ciphertext_len = file_size;
	if (file_size < 0 || file_size != (long)ciphertext_len) {
		fprintf(stderr, "file too large\n");
		return 1;
	}
	if (fseek(fp, 0L, SEEK_SET)) {
		fprintf(stderr, "fseek failed\n");
		return 1;
	}
	ciphertext = malloc(file_size);
	plaintext = malloc(file_size);
	if (!ciphertext || !plaintext) {
		fprintf(stderr, "malloc failed\n");
		return 1;
	}
	if (fread(ciphertext, 1, file_size, fp) != file_size) {
		fprintf(stderr, "read error\n");
		return 1;
	}
	if (fclose(fp)) {
		fprintf(stderr, "close error\n");
		return 1;
	}

	/* Verify file size */
	if (file_size < IV_LEN + HMAC_LEN) {
		fprintf(stderr, "ciphertext file is impossibly small\n");
		return 1;
	}

	/* Verify HMAC */
	{
		unsigned int md_len = HMAC_LEN;
		HMAC(EVP_sha256(), hmac_key, HMAC_KEY_LEN, ciphertext, ciphertext_len - HMAC_LEN, md, &md_len);
		if (memcmp(md, ciphertext + ciphertext_len - HMAC_LEN, HMAC_LEN) || md_len != HMAC_LEN) {
			fprintf(stderr, "HMAC FAILED\n");
			return 1;
		}
	}

	/* Get cipher type */
	if (!strcmp(argv[1], "PBKDF2-SHA1-AES256-HMAC-SHA256")) {
		cipher_type = EVP_aes_256_cbc();
	} else {
		fprintf(stderr, "cipher type '%s' not found\n", argv[1]);
		return 1;
	}

	/* Decrypt */
	if (!(ctx = EVP_CIPHER_CTX_new())) {
		fprintf(stderr, "EVP_CIPHER_CTX_new failed\n");
		return 1;
	}
	if (EVP_DecryptInit_ex(ctx, cipher_type, NULL, cipher_key, ciphertext) != 1) {
		fprintf(stderr, "EVP_DecryptInit_ex failed\n");
		return 1;
	}

	if (EVP_DecryptUpdate(ctx, plaintext, &len, ciphertext + IV_LEN, ciphertext_len - IV_LEN - HMAC_LEN) != 1) {
		fprintf(stderr, "EVP_DecryptUpdate failed\n");
		return 1;
	}
	plaintext_len = len;

	if (EVP_DecryptFinal_ex(ctx, plaintext + len, &len) != 1) {
		fprintf(stderr, "EVP_DecryptFinal_ex failed\n");
		return 1;
	}
	plaintext_len += len;

	/* Write plaintext */
	if (argc >= 6) {
		/* to file */
		fp = fopen(argv[5], "w");
		if (!fp) {
			fprintf(stderr, "cannot open output plaintext file %s\n", argv[4]);
			return 1;
		}
		if (fwrite(plaintext, 1, plaintext_len, fp) != plaintext_len) {
			fprintf(stderr, "write error\n");
			return 1;
		}
		if (fclose(fp)) {
			fprintf(stderr, "close error\n");
			return 1;
		}
	} else {
		/* to stdout */
		if (fwrite(plaintext, 1, plaintext_len, stdout) != plaintext_len) {
			fprintf(stderr, "write error\n");
			return 1;
		}
	}

	EVP_CIPHER_CTX_free(ctx);
	free(ciphertext);
	free(plaintext);
	return 0;
}
